/*
 * Copyright (c) 2001 by Naohide Sano, All rights reserved.
 *
 * Programmed by Naohide Sano
 */

//package vavi.util;

import java.util.*;
import java.text.*;
import vavi.util.*;

/** 
 * 和暦クラス
 *
 * GregorianCalendarは，0: 1月, 1: 2月, ... であるので，
 * getMonth(), set(int, int, int) の月が， 1: 1月 になるようにしている。 
 * 新暦である明治6年(1873年)移行をサポート。
 *
 * @todo	Calender の final メソッドの委譲が出来ていない
 * @todo	解析，フォーマット系の分離
 * @todo	明治以前の実装
 *
 * @author	城風敏彦
 * @author	<a href=mailto:vavivavi@yahoo.co.jp>Naohide Sano</a> (nsano)
 * @version	1.00	020620	城風	initial version <br>
 * @version	2.00	021119	nsano	refine <br>
 */
public class JapaneseCalendar extends Calendar {

    /** 西暦 */
    private GregorianCalendar calendar;

    /** */
    private CalendarUtilJa current;

    /**
     * 西暦での旧暦の最終日 1872/12/31
     * GregorianCalendar の仕様で，日本でいう月数に 1 を引いた値を月に入れる
     * 必要がある
     */
    public static final GregorianCalendar LAST_DAY_OF_LUNAR =
        new GregorianCalendar(1872, 11, 31);

    /** 現時刻の和暦を生成します． */
    public JapaneseCalendar() {
	setup(new GregorianCalendar());
    }

    /** 西暦インスタンスから和暦オブジェクトを生成します． */
    public JapaneseCalendar(GregorianCalendar calendar) {
	setup(calendar);
    }

    /**
     * 年、月、日から和暦オブジェクトを生成します．
     * GregorianCalendar は，1 月が 0 で表されるため，引数の月数から 1 を
     * 引いて生成
     * @param year	西暦の年
     * @param month	月 (1 ~ 12)
     * @param day	日
     */
    public JapaneseCalendar(int year, int month, int day) {
        setup(new GregorianCalendar(year, month - 1, day));
    }

    /**
     * 元号、年、月、日から和暦オブジェクトを生成します．
     * @param gengou	元号をあらわすアルファベット文字で
     *                  "M", "T", "S", "H" のいずれか
     * @param year	元号の年
     * @param month	月 (1 ~ 12)
     * @param day	日
     */
    public JapaneseCalendar(String gengou, int year, int month, int day) {
        setup(gengou, year, month, day);
    }

    /**
     * 文字列から和暦オブジェクトを生成します．
     * 受け付ける形式は現在のところ以下のとおりです．
     * <pre>
     * GYYMMDD
     * GYY-MM-DD
     * YYYYMMDD
     * YYYY-MM-DD
     * </pre>
     * "G" は元号をあらわすアルファベット文字で "M", "T", "S", "H" のいずれか
     * "-" は日付区切り文字(何でも良い)
     * "MM" は月を表す数字で 1 〜 12
     * @param dateString 日付文字列
     */
    public JapaneseCalendar(String dateString) {
        int length = dateString.length();

        if (length == 7) {		// GYYMMDD
            String gengou = dateString.substring(0, 1);
            int year  = Integer.parseInt(dateString.substring(1, 3));
            int month = Integer.parseInt(dateString.substring(3, 5));
            int day   = Integer.parseInt(dateString.substring(5, 7));

            setup(gengou, year, month, day);
        }
        else if (length == 9) {		// GYY-MM-DD
            String gengou = dateString.substring(0, 1);
            int year  = Integer.parseInt(dateString.substring(1, 3));
            int month = Integer.parseInt(dateString.substring(4, 6));
            int day   = Integer.parseInt(dateString.substring(7, 9));

            setup(gengou, year, month, day);
        }
        else if (length == 8) {		// YYYYMMDD
            int year  = Integer.parseInt(dateString.substring(0, 4));
            int month = Integer.parseInt(dateString.substring(4, 6));
            int day   = Integer.parseInt(dateString.substring(6, 8));

            setup(new GregorianCalendar(year , month - 1, day));
        }
        else if (length == 10) {	// YYYY-MM-DD
            int year  = Integer.parseInt(dateString.substring(0, 4));
            int month = Integer.parseInt(dateString.substring(5, 7));
            int day   = Integer.parseInt(dateString.substring(8, 10));

            setup(new GregorianCalendar(year , month - 1, day));
        }
        else {
            throw new IllegalArgumentException(dateString);
        }
    }

    /**
     * 元号、年、月、日から和暦オブジェクトを生成します．
     * GregorianCalendar は，1 月が 0 で表されるため，引数の月数から 1 を
     * 引いて生成
     * @param gengou	元号をあらわすアルファベット文字で
     *			"M", "T", "S", "H" のいずれか
     * @param year	元号の年
     * @param month	月 (1 ~ 12)
     * @param day	日
     */
    private void setup(String gengou, int year, int month, int day) {

        if (year < 0)
            throw new IllegalArgumentException("year: " + year);

        for (int i = 0; i < utils.size(); i++) {
            CalendarUtilJa util = (CalendarUtilJa)utils.elementAt(i);
            if (gengou.equals(util.shortName)) {
                util.check(year, month, day);
                current = util;
                this.calendar = new GregorianCalendar(year + util.diff,
                                                      month - 1,
                                                      day);
                set(year + util.diff, month - 1, day);
                return;
            }
        }

        throw new IllegalArgumentException(gengou);
    }

    /**
     * @param calendar	西暦
     */
    private void setup(GregorianCalendar calendar) {

        for (int i = 0; i < utils.size(); i++) {
            CalendarUtilJa util = (CalendarUtilJa)utils.elementAt(i);
//Debug.println(toFS(calendar) + ".before(" + toFS(util.startYear) + "): " + calendar.before(util.startYear));
//Debug.println(toFS(calendar) + ".after(" + toFS(util.endYear) + "): " + calendar.after(util.endYear));
            if (!(calendar.before(util.startYear) ||
                  calendar.after(util.endYear))) {
                current = util;
                this.calendar = calendar;
                set(calendar.get(Calendar.YEAR),
                    calendar.get(Calendar.MONTH),
                    calendar.get(Calendar.DAY_OF_MONTH));
                return;
            }
        }

        throw new IllegalArgumentException(toFS(calendar));
    }

    /**
     * 
     * @param field java.util.GregorianCalendarのフィールド
     * @return int
     */
    public int get(int field) {
        return calendar.get(field);
    }

    /**
     * 元号を取得します．
     * @return 元号の文字列
     */
    public String getGengou() {
        return current.shortName;
    }

    /**
     * 和暦の年を取得します．
     * @return 元号の年
     */
    public int getYear() {
        return calendar.get(Calendar.YEAR) - current.diff;
    }

    /** 月の取得 */
    public int getMonth() {
        return calendar.get(Calendar.MONTH) + 1;
    }

    /** 日の取得 */
    public int getDay() {
        return calendar.get(Calendar.DAY_OF_MONTH);
    }

    //----

    /**
     * カレンダの規則に基づいて、指定された (符号付きの) 時間量を、指定された
     * 時間フィールドに加えます。  
     */
    public void add(int field, int amount) {
        calendar.add(field, amount);
    }

    /** Calendar をオーバーライドします。 */
    protected void computeFields() {
Debug.println("not implemented");	// @@@
    }

    /** Calendar をオーバーライドします。 */
    protected void computeTime() {
Debug.println("not implemented");	// @@@
    }

    /** この GregorianCalendar とオブジェクト参照を比較します。 */
    public boolean equals(Object obj) {
        return calendar.equals(obj);
    }

    /** 指定されたフィールドが変化する場合、その最大値を返します。 */
    public int getGreatestMinimum(int field) {
        return calendar.getGreatestMinimum(field);
    }

    /** 指定されたフィールドが変化する場合、その最小の最大値を返します。 */
    public int getLeastMaximum(int field) {
        return calendar.getLeastMaximum(field);
    }

    /**
     * 指定されたフィールドの最大値 (たとえば、グレゴリオ暦の DAY_OF_MONTH
     * では、31) を返します。
     */
    public int getMaximum(int field) {
        return calendar.getMaximum(field);
    }

    /**
     * 指定されたフィールドの最小値
     * (たとえば、グレゴリオ暦の DAY_OF_MONTH では、1) を返します。
     */
    public int getMinimum(int field) {
        return calendar.getMinimum(field);
    }

    /** 指定された年が、うるう年かどうかを判定します。 */
    public boolean isLeapYear(int year) {
        return calendar.isLeapYear(year);
    }

    /**
     * 大きいフィールドを変更せずに指定された時間フィールドの
     * 1 つの単位の時間を上または下に加算または減算します。
     */
    public void roll(int field, boolean up) {
        calendar.roll(field, up);
    }

    //----

    /**
     * 元号，年月日を設定します．
     * @param gengou	元号
     * @param year	元号の年
     * @param month	月 (1 ~ 12)
     * @param day	日
     */
    public void set(String gengou, int year, int month, int day) {
        for (int i = 0; i < utils.size(); i++) {
            CalendarUtilJa util = (CalendarUtilJa)utils.elementAt(i);
            if (gengou.equals(util.shortName)) {
                current = util;
                calendar.set(year + util.diff, month - 1, day);
                set(year + util.diff, month - 1, day);
            }
        }

        throw new IllegalArgumentException(gengou);
    }

    /** GYY/MM/DD 形式の String に変換。 */
    public String toString() {
        return
            getGengou() + Integer.toString(getYear()) + "/" +
            Integer.toString(getMonth()) + "/" +
            Integer.toString(getDay());
    }

    /** YY/MM/DD 形式の String に変換。 */
    public String toEString() {
        return
            Integer.toString(get(GregorianCalendar.YEAR)) + "/" +
            Integer.toString(getMonth()) + "/" +
            Integer.toString(getDay());
    }

    /** 元号 YY 年 MM 年 DD 日の String に変換 */
    public String toJString() {
        int year = getYear();
        String result = new String();
        if (year == 1) {
            result = "元";
        }
        else {
            result = Integer.toString(year);
        }

        return
            current.name + result +
            "年" +
            Integer.toString(calendar.get(Calendar.MONTH) + 1) +
            "月" +
            Integer.toString(calendar.get(Calendar.DAY_OF_MONTH)) +
            "日";
    }

    /** for debug */
    private static final String toFS(Calendar calendar) {
        SimpleDateFormat sdf = new SimpleDateFormat("yyyy/MM/dd");
        return sdf.format(calendar.getTime()).toString();
    }

    /** */
    private static class CalendarUtilJa {
        /** 元号の省略表記 */
        String shortName;
        /** 元号 */
        String name;
        /** 西暦での開始日 */
        GregorianCalendar startYear;
        /** 西暦での最終日 */
        GregorianCalendar endYear;
        /** 西暦との差分 */
        int diff;

        /**
         * します．
         * @param year	元号の年
         * @param month	月 (1 ~ 12)
         * @param day	日
         */
        public void check(int year, int month, int day) {
            GregorianCalendar cal =
                new GregorianCalendar(year + diff, month - 1, day);

            if (cal.before(startYear) || cal.after(endYear)) {
                throw new IllegalArgumentException(
                    shortName + year + "/" + month + "/" + day);
            }
        }

        void debug() {
            Debug.println(shortName);
            Debug.println(name);
            Debug.println(toFS(startYear));
            Debug.println(toFS(endYear));
            Debug.println(diff);
        }
    }

    /** */
    private static final ResourceBundle rb =
        ResourceBundle.getBundle("resource", Locale.getDefault());

    /** */
    private static final Vector utils = new Vector();

    /** */
    static {

        try {
            int i = 0;
            while (true) {
                CalendarUtilJa util = new CalendarUtilJa();

                // shortName
                String value;
                try {
                    value = rb.getString("calendar.ja." + i + ".gengou.short");
                }
                catch (MissingResourceException e) {
Debug.println("calender util: " + i + " not found, break");
                    break;
                }
                util.shortName = value;

                // name
                value = rb.getString("calendar.ja." + i + ".gengou.name");
                util.name = value;

                // startYear
                value = rb.getString("calendar.ja." + i + ".year.start");
                StringTokenizer st = new StringTokenizer(value, " ,");
                int year  = Integer.parseInt(st.nextToken());
                int month = Integer.parseInt(st.nextToken());
                int day   = Integer.parseInt(st.nextToken());
                util.startYear = new GregorianCalendar(year, month, day);

                // endYear
                value = rb.getString("calendar.ja." + i + ".year.end");
                st = new StringTokenizer(value, " ,");
                year  = Integer.parseInt(st.nextToken());
                month = Integer.parseInt(st.nextToken());
                day   = Integer.parseInt(st.nextToken());
                util.endYear = new GregorianCalendar(year, month, day);

                value = rb.getString("calendar.ja." + i + ".year.diff");
                util.diff = Integer.parseInt(value);

Debug.println("---- " + i + " ----");
util.debug();
                utils.addElement(util);

                i++;
            }
        }
        catch (Exception e) {
Debug.printStackTrace(e);
        }
    }

    /** */
    public static void main(String[] args) {

        JapaneseCalendar jc;

        if (args.length == 2 && "-d".equals(args[0])) {

            jc = new JapaneseCalendar(args[1]);
            System.out.println(jc.toJString());
            System.exit(0);
        }

        jc = new JapaneseCalendar();
        System.out.println("Today " + jc);
        System.out.println("Today " + jc.toJString());

        jc = new JapaneseCalendar("00010203");
        System.out.println("00010203 " + jc);
        System.out.println("00010203 " + jc.toEString());

        jc = new JapaneseCalendar("19890203");
        System.out.println("19890203 " + jc);

        jc = new JapaneseCalendar("19890107");
        System.out.println("19890107 " + jc);

        jc = new JapaneseCalendar("S", 64, 1, 7);
        System.out.println("S 64 1 7 " + jc);

        jc = new JapaneseCalendar("H", 1, 1, 8);
        System.out.println("H 1 1 8 " + jc);

        jc = new JapaneseCalendar(1989, 1, 8);
        System.out.println("1989 1 8 " + jc);

        jc = new JapaneseCalendar("S", 20, 8, 15);
        System.out.println("S 20 8 15 " + jc);
        System.out.println(jc.toJString());

        jc = new JapaneseCalendar("T111209");
        System.out.println("T111209 " + jc);
        System.out.println("T111209 " + jc.toJString());

        jc.set(2001, 8 - 1, 11);		// @@@ 機能していない
        System.out.println("2001 8 11 " + jc);
        System.out.println("2001 8 11 " + jc.toJString());
    }
}

/* */
